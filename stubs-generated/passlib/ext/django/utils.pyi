# Stubs for passlib.ext.django.utils (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from django import VERSION as DJANGO_VERSION
from typing import Any, Optional

MIN_DJANGO_VERSION: Any

def get_preset_config(name: Any): ...

class DjangoTranslator:
    context: Any = ...
    def __init__(self, context: Optional[Any] = ..., **kwds: Any) -> None: ...
    def reset_hashers(self) -> None: ...
    def passlib_to_django_name(self, passlib_name: Any): ...
    def passlib_to_django(self, passlib_hasher: Any, cached: bool = ...): ...
    def django_to_passlib_name(self, django_name: Any): ...
    def django_to_passlib(self, django_name: Any, cached: bool = ...): ...
    def resolve_django_hasher(self, django_name: Any, cached: bool = ...): ...

class DjangoContextAdapter(DjangoTranslator):
    context: Any = ...
    is_password_usable: Any = ...
    enabled: bool = ...
    patched: bool = ...
    log: Any = ...
    get_user_category: Any = ...
    get_hashers: Any = ...
    def __init__(self, context: Optional[Any] = ..., get_user_category: Optional[Any] = ..., **kwds: Any) -> None: ...
    def reset_hashers(self) -> None: ...
    def get_hashers(self): ...
    def get_hasher(self, algorithm: str = ...): ...
    def identify_hasher(self, encoded: Any): ...
    def make_password(self, password: Any, salt: Optional[Any] = ..., hasher: str = ...): ...
    def check_password(self, password: Any, encoded: Any, setter: Optional[Any] = ..., preferred: str = ...): ...
    def user_check_password(self, user: Any, password: Any): ...
    def user_set_password(self, user: Any, password: Any) -> None: ...
    def get_user_category(self, user: Any): ...
    HASHERS_PATH: str = ...
    MODELS_PATH: str = ...
    USER_CLASS_PATH: Any = ...
    FORMS_PATH: str = ...
    patch_locations: Any = ...
    def install_patch(self): ...
    def remove_patch(self): ...
    def load_model(self) -> None: ...

class ProxyProperty:
    attr: Any = ...
    def __init__(self, attr: Any) -> None: ...
    def __get__(self, obj: Any, cls: Any): ...
    def __set__(self, obj: Any, value: Any) -> None: ...
    def __delete__(self, obj: Any) -> None: ...

class _PasslibHasherWrapper:
    passlib_handler: Any = ...
    rounds: Any = ...
    iterations: Any = ...
    def __init__(self, passlib_handler: Any) -> None: ...
    def __name__(self): ...
    def algorithm(self): ...
    def salt(self): ...
    def verify(self, password: Any, encoded: Any): ...
    def encode(self, password: Any, salt: Optional[Any] = ..., rounds: Optional[Any] = ..., iterations: Optional[Any] = ...): ...
    def safe_summary(self, encoded: Any): ...
    def must_update(self, encoded: Any): ...

class _PatchManager:
    log: Any = ...
    def __init__(self, log: Optional[Any] = ...) -> None: ...
    def isactive(self): ...
    __bool__: Any = ...
    __nonzero__: Any = ...
    def get(self, path: Any, default: Optional[Any] = ...): ...
    def getorig(self, path: Any, default: Optional[Any] = ...): ...
    def check_all(self, strict: bool = ...) -> None: ...
    def patch(self, path: Any, value: Any, wrap: bool = ...): ...
    @classmethod
    def peek_unpatched_func(cls, value: Any): ...
    def monkeypatch(self, parent: Any, name: Optional[Any] = ..., enable: bool = ..., wrap: bool = ...): ...
    def unpatch(self, path: Any, unpatch_conflicts: bool = ...) -> None: ...
    def unpatch_all(self, **kwds: Any) -> None: ...

# Names in __all__ with no definition:
#   get_django_hasher
