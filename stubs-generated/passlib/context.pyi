# Stubs for passlib.context (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class CryptPolicy:
    @classmethod
    def from_path(cls, path: Any, section: str = ..., encoding: str = ...): ...
    @classmethod
    def from_string(cls, source: Any, section: str = ..., encoding: str = ...): ...
    @classmethod
    def from_source(cls, source: Any, _warn: bool = ...): ...
    @classmethod
    def from_sources(cls, sources: Any, _warn: bool = ...): ...
    def replace(self, *args: Any, **kwds: Any): ...
    def __init__(self, *args: Any, **kwds: Any) -> None: ...
    def has_schemes(self): ...
    def iter_handlers(self): ...
    def schemes(self, resolve: bool = ...): ...
    def get_handler(self, name: Optional[Any] = ..., category: Optional[Any] = ..., required: bool = ...): ...
    def get_min_verify_time(self, category: Optional[Any] = ...): ...
    def get_options(self, name: Any, category: Optional[Any] = ...): ...
    def handler_is_deprecated(self, name: Any, category: Optional[Any] = ...): ...
    def iter_config(self, ini: bool = ..., resolve: bool = ...): ...
    def to_dict(self, resolve: bool = ...): ...
    def to_file(self, stream: Any, section: str = ...) -> None: ...
    def to_string(self, section: str = ..., encoding: Optional[Any] = ...): ...

class _CryptConfig:
    handlers: Any = ...
    schemes: Any = ...
    categories: Any = ...
    context_kwds: Any = ...
    def __init__(self, source: Any) -> None: ...
    def get_context_optionmap(self, key: Any, _default: Any = ...): ...
    def get_context_option_with_flag(self, category: Any, key: Any): ...
    def get_base_handler(self, scheme: Any): ...
    @staticmethod
    def expand_settings(handler: Any): ...
    def get_scheme_options_with_flag(self, scheme: Any, category: Any): ...
    def default_scheme(self, category: Any): ...
    def is_deprecated_with_flag(self, scheme: Any, category: Any): ...
    def get_record(self, scheme: Any, category: Any): ...
    def identify_record(self, hash: Any, category: Any, required: bool = ...): ...
    def disabled_record(self): ...
    def iter_config(self, resolve: bool = ...) -> None: ...

class CryptContext:
    @classmethod
    def from_string(cls, source: Any, section: str = ..., encoding: str = ...): ...
    @classmethod
    def from_path(cls, path: Any, section: str = ..., encoding: str = ...): ...
    def copy(self, **kwds: Any): ...
    def using(self, **kwds: Any): ...
    def replace(self, **kwds: Any): ...
    def __init__(self, schemes: Optional[Any] = ..., policy: Any = ..., _autoload: bool = ..., **kwds: Any) -> None: ...
    policy: Any = ...
    def load_path(self, path: Any, update: bool = ..., section: str = ..., encoding: str = ...): ...
    def load(self, source: Any, update: bool = ..., section: str = ..., encoding: str = ...) -> None: ...
    def update(self, *args: Any, **kwds: Any) -> None: ...
    def schemes(self, resolve: bool = ..., category: Optional[Any] = ..., unconfigured: bool = ...): ...
    def default_scheme(self, category: Optional[Any] = ..., resolve: bool = ..., unconfigured: bool = ...): ...
    def handler(self, scheme: Optional[Any] = ..., category: Optional[Any] = ..., unconfigured: bool = ...): ...
    @property
    def context_kwds(self): ...
    def to_dict(self, resolve: bool = ...): ...
    def to_string(self, section: str = ...): ...
    mvt_estimate_max_samples: int = ...
    mvt_estimate_min_samples: int = ...
    mvt_estimate_max_time: int = ...
    mvt_estimate_resolution: float = ...
    harden_verify: Any = ...
    min_verify_time: int = ...
    def reset_min_verify_time(self) -> None: ...
    def needs_update(self, hash: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ..., secret: Optional[Any] = ...): ...
    def hash_needs_update(self, hash: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ...): ...
    def genconfig(self, scheme: Optional[Any] = ..., category: Optional[Any] = ..., **settings: Any): ...
    def genhash(self, secret: Any, config: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ..., **kwds: Any): ...
    def identify(self, hash: Any, category: Optional[Any] = ..., resolve: bool = ..., required: bool = ..., unconfigured: bool = ...): ...
    def hash(self, secret: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ..., **kwds: Any): ...
    def encrypt(self, *args: Any, **kwds: Any): ...
    def verify(self, secret: Any, hash: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ..., **kwds: Any): ...
    def verify_and_update(self, secret: Any, hash: Any, scheme: Optional[Any] = ..., category: Optional[Any] = ..., **kwds: Any): ...
    def dummy_verify(self, elapsed: int = ...): ...
    def is_enabled(self, hash: Any): ...
    def disable(self, hash: Optional[Any] = ...): ...
    def enable(self, hash: Any): ...

class LazyCryptContext(CryptContext):
    def __init__(self, schemes: Optional[Any] = ..., **kwds: Any) -> None: ...
    def __getattribute__(self, attr: Any): ...
